From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Mon, 25 Nov 2019 03:46:45 -0800
Subject: [PATCH] Improve autosave performance

Autosave performance is improved since we spend less iterations looking
for a chunk to save, as we only iterate on chunks that could be saved
and were ordered by last save / load time

diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 9a1c2110a651c77fb265bfbb2e72c9a744d20c23..7fc001977446ececb237044311353857dcc81ce5 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -40,6 +40,9 @@ public class PlayerChunk {
 
     /* Concrete start */
     private final PlayerChunkMap chunkMap;
+
+    long lastAutoSaveTime;
+    long inactiveTimeStart;
     /* Concrete end */
 
     public PlayerChunk(ChunkCoordIntPair chunkcoordintpair, int i, LightEngine lightengine, PlayerChunk.c playerchunk_c, PlayerChunk.d playerchunk_d) {
@@ -57,7 +60,7 @@ public class PlayerChunk {
         this.ticketLevel = this.oldTicketLevel;
         this.n = this.oldTicketLevel;
         this.a(i);
-        this.chunkMap = (PlayerChunkMap)playerchunk_d; /* Concrete  */
+        this.chunkMap = (PlayerChunkMap)playerchunk_d; /* Concrete */
     }
 
     // CraftBukkit start
@@ -433,7 +436,19 @@ public class PlayerChunk {
         boolean flag2 = playerchunk_state.isAtLeast(PlayerChunk.State.BORDER);
         boolean flag3 = playerchunk_state1.isAtLeast(PlayerChunk.State.BORDER);
 
+        boolean prevHasBeenLoaded = this.hasBeenLoaded; /* Concrete */
         this.hasBeenLoaded |= flag3;
+        /* Concrete start */
+        if (this.hasBeenLoaded & !prevHasBeenLoaded) {
+            long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
+            if (timeSinceAutoSave < 0) {
+                // safest bet is to assume autosave is needed here
+                timeSinceAutoSave = this.chunkMap.world.paperConfig.autoSavePeriod;
+            }
+            this.lastAutoSaveTime = this.chunkMap.world.getTime() - timeSinceAutoSave;
+            this.chunkMap.autoSaveQueue.add(this);
+        }
+        /* Concrete end */
         if (!flag2 && flag3) {
             this.fullChunkFuture = playerchunkmap.b(this);
             this.a(this.fullChunkFuture);
@@ -542,9 +557,33 @@ public class PlayerChunk {
     }
 
     public void m() {
+        boolean prev = this.hasBeenLoaded; /* Concrete */
         this.hasBeenLoaded = getChunkState(this.ticketLevel).isAtLeast(PlayerChunk.State.BORDER);
+        /* Concrete start */
+        if (prev != this.hasBeenLoaded) {
+            if (this.hasBeenLoaded) {
+                long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
+                if (timeSinceAutoSave < 0) {
+                    // safest bet is to assume autosave is needed here
+                    timeSinceAutoSave = this.chunkMap.world.paperConfig.autoSavePeriod;
+                }
+                this.lastAutoSaveTime = this.chunkMap.world.getTime() - timeSinceAutoSave;
+                this.chunkMap.autoSaveQueue.add(this);
+            } else {
+                this.inactiveTimeStart = this.chunkMap.world.getTime();
+                this.chunkMap.autoSaveQueue.remove(this);
+            }
+        }
+        /* Concrete end */
     }
 
+    /* Concrete start */
+    public boolean setHasBeenLoaded() {
+        this.hasBeenLoaded = getChunkState(this.ticketLevel).isAtLeast(PlayerChunk.State.BORDER);
+        return this.hasBeenLoaded;
+    }
+    /* Concrete end */
+
     public void a(ProtoChunkExtension protochunkextension) {
         for (int i = 0; i < this.statusFutures.length(); ++i) {
             CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> completablefuture = (CompletableFuture) this.statusFutures.get(i);
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 0ea9f4defc10bc1b44762342e08aedaabd8488d1..4f129c24d70c201e08c850101b4cbc3f45b21e23 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -204,6 +204,16 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             this.playerEntityTrackerUntrackMap.update(player, chunkX, chunkZ, Math.min(this.entityTrackerUntrackRange, effectiveViewDistance));
         }
     }
+
+    final it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<PlayerChunk> autoSaveQueue = new it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<>((playerchunk1, playerchunk2) -> {
+        int ret =  Long.compare(playerchunk1.lastAutoSaveTime, playerchunk2.lastAutoSaveTime);
+
+        if (ret != 0) {
+            return ret;
+        }
+
+        return Long.compare(ca.spottedleaf.concrete.util.Util.getCoordinateKey(playerchunk1.location), ca.spottedleaf.concrete.util.Util.getCoordinateKey(playerchunk2.location));
+    });
     /* Concrete end */
 
     public PlayerChunkMap(WorldServer worldserver, File file, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator<?> chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i) {
@@ -542,30 +552,48 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper start - derived from below
     protected void saveIncrementally() {
         int savedThisTick = 0;
-        for (PlayerChunk playerchunk : this.chunkMap.getVisibleValues()) { /* Concrete - replace chunk map */
-            if (playerchunk.hasBeenLoaded()) {
-
-                IChunkAccess ichunkaccess = (IChunkAccess) playerchunk.getChunkSave().getNow(null); // CraftBukkit - decompile error
-
-
-                if (ichunkaccess instanceof ProtoChunkExtension || ichunkaccess instanceof Chunk) {
-                    boolean shouldSave = true;
-
-                    if (ichunkaccess instanceof Chunk) {
-                        shouldSave = ((Chunk) ichunkaccess).lastSaved + world.paperConfig.autoSavePeriod <= world.getTime();
-                    }
-
-                    if (shouldSave && this.saveChunk(ichunkaccess, true)) { // Paper - async chunk io
-                        ++savedThisTick;
-                        playerchunk.m();
+        /* Concrete start - optimize */
+        // optimized since we search far less chunks to hit ones that need to be saved
+        List<PlayerChunk> reschedule = new ArrayList<>(this.world.paperConfig.maxAutoSaveChunksPerTick);
+        long currentTick = this.world.getTime();
+        long maxSaveTime = currentTick - this.world.paperConfig.autoSavePeriod;
+        for (Iterator<PlayerChunk> iterator = this.autoSaveQueue.iterator(); iterator.hasNext();) { /* Concrete - replace chunk map */
+            PlayerChunk playerchunk = iterator.next();
+            if (playerchunk.lastAutoSaveTime > maxSaveTime) {
+                break;
+            }
+            iterator.remove();
+            IChunkAccess ichunkaccess = playerchunk.getChunkSave().getNow(null); // CraftBukkit - decompile error
+
+            if (ichunkaccess instanceof Chunk) {
+                boolean shouldSave = ((Chunk)ichunkaccess).lastSaved <= maxSaveTime;
+
+                if (shouldSave && this.saveChunk(ichunkaccess, true)) { // Paper - async chunk io
+                    ++savedThisTick;
+                    if (!playerchunk.setHasBeenLoaded()) {
+                        // do not fall through to reschedule logic
+                        playerchunk.inactiveTimeStart = currentTick;
+                        if (savedThisTick >= this.world.paperConfig.maxAutoSaveChunksPerTick) {
+                            break;
+                        }
+                        continue;
                     }
                 }
+            }
 
-                if (savedThisTick >= world.paperConfig.maxAutoSaveChunksPerTick) {
-                    return;
-                }
+            reschedule.add(playerchunk);
+
+            if (savedThisTick >= this.world.paperConfig.maxAutoSaveChunksPerTick) {
+                break;
             }
         }
+
+        for (int i = 0, len = reschedule.size(); i < len; ++i) {
+            PlayerChunk playerchunk = reschedule.get(i);
+            playerchunk.lastAutoSaveTime = this.world.getTime();
+            this.autoSaveQueue.add(playerchunk);
+        }
+        /* Concrete end */
     }
     // paper end
 
@@ -740,6 +768,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         this.world.unloadChunk(chunk);
                     }
 
+                    this.autoSaveQueue.remove(playerchunk); /* Concrete */
+
                     try {
                         this.asyncSave(ichunkaccess); // Paper - async chunk saving
                     } catch (Throwable ex) {
